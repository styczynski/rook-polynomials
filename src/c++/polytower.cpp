#include <iostream>
#include <string>
#include <sstream>

/**
 Max board size
**/
#define N 1007
using namespace std;

/**
 * Board matrices
**/
int board[N][N];
bool boardAllowedFields[N][N];

/**
 * Helper function to convert ints to strings.
**/
string intToStr(int n) {
    std::ostringstream out;
    out << n;
    return out.str();
}


/**
 * A utility function to check if the towers on the board
 * are placed correctly (does not attack themselves)
 *
 *  board - NxN 0/1 matrix containing tower positions.
 *  row - number of field row that is checked
 *  column - number of field column that is checked
 * Returns bool - true if tower at position (row, column) does not attac
 * anything
 **/
static bool isSafePlacement(int dim, int row, int column) {
  /* Check attacting on the left side of a tower*/
  for (int i = 0; i < column; i++) {
    if (board[row][i] > 0) {
      return false;
    }
  }

  return true;
}

/**
 * Variable to capture number of solutions generated by solveRec
 **/
static int numberOfSolutions = 0;

/**
 *
 * A recursive function to solve a problem where there is
 * {towToBePlaced} towers to place on board with allowed places marked in
 * {boardAllowedFields} matrix.
 * Number of currently placed towers is {towPlaced} and they are placed in
 * {board matrix}.
 * {column} is number of column that is already being matched.
 * The recursive function works in backtracking manner.
 * Board matrix is modified but left as it was after function exit.
 * Function saves number of found configurations in {numberOfSolutions}
 * variable.
 *
 *
 *  board - Empty NxN 0/1 matrix used as helper (left empty at exit)
 *  boardAllowedFields - NxN 0/1 matrix marking available board fields
 *  towToBePlaced - Total number of tower to be placed
 *  towPlaced - Currently placed towers
 *  column - Number of column currently modified
 */
static void solveRec(int dim, int towToBePlaced, int towPlaced, int column) {

  if (towPlaced == towToBePlaced && column >= dim) {
    numberOfSolutions++;
  }

  if (column >= dim) {
    return;
  }

  for (int i = 0; i < dim; i++) {
    if (isSafePlacement(dim, i, column) && boardAllowedFields[i][column]) {
      board[i][column] = 1;
      solveRec(dim, towToBePlaced, towPlaced + 1, column + 1);
      board[i][column] = 0;
    }
  }
  solveRec(dim, towToBePlaced, towPlaced, column + 1);
}

/**
 * Function to find number of tower-placing solutions for given board.
 *
 *  board - Empty NxN 0/1 matrix used as helper (left empty at exit)
 *  boardAllowedFields - NxN 0/1 matrix marking available board fields
 *  towToBePlaced - Total number of tower to be placed
 * Returns number of solutions
 */
static int solve(int dim, int towToBePlaced) {
  numberOfSolutions = 0;
  solveRec(dim, towToBePlaced, 0, 0);
  return numberOfSolutions;
}

/**
 * Function generating tower-polynomial (polytower) for given board.
 * It returns array of polynomial factors.
 * * int[0] will be polynomial constant
 * * int[1] is factor associated with x^1
 * * etc.
 *
 *  boardAllowedFields - NxN 0/1 matrix marking available board fields
 * Returns int[] with polynomial factors
 */
static int* generatePolytower(int dim) {
  int qmax = 0;

  for (int y = 0; y < dim; ++y) {
    for (int x = 0; x < dim; ++x) {
      if (boardAllowedFields[y][x]) ++qmax;
    }
  }

  int* polytower = new int[qmax + 2];
  for (int i = 0; i <= qmax; ++i) {
    polytower[i] = 0;
  }

  for (int y = 0; y < dim; ++y) {
    for (int x = 0; x < dim; ++x) {
      board[y][x] = 0;
    }
  }

  for (int q = 0; q <= qmax; ++q) {
    polytower[q] = solve(dim, q);
  }
  polytower[qmax+1]=-1;
  return polytower;
}

/**
 * Function converting polytower factors to normalized
 * human-readable form.
 *
 *  polytower - int[] polytower
 * Returns string representation of given polynomial
 */
static string polytowerTostring(int* polytower) {
  string result = "";
  bool addLeadingOp = false;
  int i = 0;
  while(polytower[i]!=-1) {
    if (i == 0 && polytower[0] != 0) {
      result += intToStr(polytower[0]);
      addLeadingOp = true;
    } else if (i == 1 && polytower[1] != 0) {
      if (addLeadingOp) result += (" + ");
      if (polytower[1] == 1) {
        result += ("x");
      } else {
        result += (intToStr(polytower[1]) + "x");
      }
      addLeadingOp = true;
    } else if (polytower[i] != 0) {
      if (addLeadingOp) result += (" + ");
      if (polytower[i] == 1) {
        result += ("x^" + intToStr(i));
      } else {
        result += (intToStr(polytower[i]) + "x^" + intToStr(i));
      }
      addLeadingOp = true;
    }
    ++i;
  }
  return result;
}

/**
 * Function printing polytower in normalized
 * human-readable form to the standard output.
 *
 *  polytower - int[] polytower
 */
static void printPolytower(int* polytower) {
  cout << polytowerTostring(polytower) << "\n";
}


/**
 * Main function loading I/O and calculating polytower
**/
int main(void) {
	ios_base::sync_with_stdio(0);
	
	
	int dim = 0;
	cin >> dim;
	string linebuf = "";
	getline(cin, linebuf);

	for(int y=0;y<dim;++y) {
		getline(cin, linebuf);
		for(int x=0;x<dim;++x) {
			boardAllowedFields[y][x] = (linebuf[x]=='#');
		}
	}
		
	int* polytower = generatePolytower(dim);
	printPolytower(polytower);
		
	return 0;	
}
